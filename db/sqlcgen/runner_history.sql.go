// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: runner_history.sql

package sqlcgen

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const findRunnerHistoriesByRunnerID = `-- name: FindRunnerHistoriesByRunnerID :many
SELECT
    id,
    runner_id,
    runner_name,
    status,
    message,
    started_at,
    ended_at,
    response_time_ms,
    created_at
FROM runner_histories
WHERE runner_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindRunnerHistoriesByRunnerID(ctx context.Context, runnerID uuid.UUID) ([]RunnerHistory, error) {
	rows, err := q.db.Query(ctx, findRunnerHistoriesByRunnerID, runnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunnerHistory
	for rows.Next() {
		var i RunnerHistory
		if err := rows.Scan(
			&i.ID,
			&i.RunnerID,
			&i.RunnerName,
			&i.Status,
			&i.Message,
			&i.StartedAt,
			&i.EndedAt,
			&i.ResponseTimeMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveRunnerHistory = `-- name: SaveRunnerHistory :exec
INSERT INTO runner_histories (
    id,
    runner_id,
    runner_name,
    status,
    message,
    started_at,
    ended_at,
    response_time_ms,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, now()
)
`

type SaveRunnerHistoryParams struct {
	ID             uuid.UUID  `json:"id"`
	RunnerID       uuid.UUID  `json:"runner_id"`
	RunnerName     string     `json:"runner_name"`
	Status         string     `json:"status"`
	Message        *string    `json:"message"`
	StartedAt      *time.Time `json:"started_at"`
	EndedAt        *time.Time `json:"ended_at"`
	ResponseTimeMs *int32     `json:"response_time_ms"`
}

func (q *Queries) SaveRunnerHistory(ctx context.Context, arg SaveRunnerHistoryParams) error {
	_, err := q.db.Exec(ctx, saveRunnerHistory,
		arg.ID,
		arg.RunnerID,
		arg.RunnerName,
		arg.Status,
		arg.Message,
		arg.StartedAt,
		arg.EndedAt,
		arg.ResponseTimeMs,
	)
	return err
}

const searchRunnerHistories = `-- name: SearchRunnerHistories :many
SELECT
    rh.id,
    rh.runner_id,
    rh.runner_name,
    rh.status,
    rh.message,
    rh.started_at,
    rh.ended_at,
    rh.response_time_ms,
    rh.created_at
FROM runner_histories AS rh
JOIN runners AS r ON rh.runner_id = r.id
WHERE 
    r.user_id = $1
    AND rh.status = $2
    AND rh.created_at BETWEEN (NOW() - ($3::int * INTERVAL '1 minute')) AND NOW()
ORDER BY rh.created_at DESC
`

type SearchRunnerHistoriesParams struct {
	UserID  uuid.UUID `json:"user_id"`
	Status  string    `json:"status"`
	Minutes int32     `json:"minutes"`
}

func (q *Queries) SearchRunnerHistories(ctx context.Context, arg SearchRunnerHistoriesParams) ([]RunnerHistory, error) {
	rows, err := q.db.Query(ctx, searchRunnerHistories, arg.UserID, arg.Status, arg.Minutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RunnerHistory
	for rows.Next() {
		var i RunnerHistory
		if err := rows.Scan(
			&i.ID,
			&i.RunnerID,
			&i.RunnerName,
			&i.Status,
			&i.Message,
			&i.StartedAt,
			&i.EndedAt,
			&i.ResponseTimeMs,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: runners.sql

package sqlcgen

import (
	"context"

	"github.com/google/uuid"
)

const createRunner = `-- name: CreateRunner :one
INSERT INTO runners (
    id, user_id, monitor_id, name, region, interval_second, is_enabled
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, monitor_id, name, region, interval_second, is_enabled, created_at, updated_at
`

type CreateRunnerParams struct {
	ID             uuid.UUID `json:"id"`
	UserID         uuid.UUID `json:"user_id"`
	MonitorID      uuid.UUID `json:"monitor_id"`
	Name           string    `json:"name"`
	Region         string    `json:"region"`
	IntervalSecond int32     `json:"interval_second"`
	IsEnabled      bool      `json:"is_enabled"`
}

func (q *Queries) CreateRunner(ctx context.Context, arg CreateRunnerParams) (Runner, error) {
	row := q.db.QueryRow(ctx, createRunner,
		arg.ID,
		arg.UserID,
		arg.MonitorID,
		arg.Name,
		arg.Region,
		arg.IntervalSecond,
		arg.IsEnabled,
	)
	var i Runner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MonitorID,
		&i.Name,
		&i.Region,
		&i.IntervalSecond,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRunner = `-- name: DeleteRunner :exec
DELETE FROM runners
WHERE id = $1
`

func (q *Queries) DeleteRunner(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRunner, id)
	return err
}

const findAllRunners = `-- name: FindAllRunners :many
SELECT id, user_id, monitor_id, name, region, interval_second, is_enabled, created_at, updated_at 
FROM runners
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) FindAllRunners(ctx context.Context, userID uuid.UUID) ([]Runner, error) {
	rows, err := q.db.Query(ctx, findAllRunners, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Runner
	for rows.Next() {
		var i Runner
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.MonitorID,
			&i.Name,
			&i.Region,
			&i.IntervalSecond,
			&i.IsEnabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRunnerByID = `-- name: FindRunnerByID :one
SELECT id, user_id, monitor_id, name, region, interval_second, is_enabled, created_at, updated_at 
FROM runners
WHERE id = $1
`

func (q *Queries) FindRunnerByID(ctx context.Context, id uuid.UUID) (Runner, error) {
	row := q.db.QueryRow(ctx, findRunnerByID, id)
	var i Runner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MonitorID,
		&i.Name,
		&i.Region,
		&i.IntervalSecond,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRunner = `-- name: UpdateRunner :one
UPDATE runners
SET 
    monitor_id = $2,
    name = $3,
    region = $4,
    interval_second = $5,
    is_enabled = $6,
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, monitor_id, name, region, interval_second, is_enabled, created_at, updated_at
`

type UpdateRunnerParams struct {
	ID             uuid.UUID `json:"id"`
	MonitorID      uuid.UUID `json:"monitor_id"`
	Name           string    `json:"name"`
	Region         string    `json:"region"`
	IntervalSecond int32     `json:"interval_second"`
	IsEnabled      bool      `json:"is_enabled"`
}

func (q *Queries) UpdateRunner(ctx context.Context, arg UpdateRunnerParams) (Runner, error) {
	row := q.db.QueryRow(ctx, updateRunner,
		arg.ID,
		arg.MonitorID,
		arg.Name,
		arg.Region,
		arg.IntervalSecond,
		arg.IsEnabled,
	)
	var i Runner
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.MonitorID,
		&i.Name,
		&i.Region,
		&i.IntervalSecond,
		&i.IsEnabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
